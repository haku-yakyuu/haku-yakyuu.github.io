---
import Layout from '../layouts/Layout.astro';
import ProductCard from '../components/ProductCard.astro';
import { getHakuData } from '../utils/api';

const { products, config, solidTagsList } = await getHakuData();

// 1. 精選商品 (Featured) -> 預設直式網格
const featured = products.filter(p => p.isFeatured);

// 2. 其餘商品分類 (排除精選)
const others = products.filter(p => !p.isFeatured);

// Helper: 根據內容的 layout 屬性，決定要用哪種網格 Class
function getGridClass(items) {
    if (items.length === 0) return 'grid-vertical';
    const type = items[0].layout; // 以第一筆資料為準
    if (type === 'horizontal') return 'grid-horizontal-img';   // PC 3欄
    if (type === 'no_image') return 'grid-horizontal-noimg';   // PC 4欄 (高密度)
    return 'grid-vertical';                                    // PC 4欄
}

// 為了展示效果，我們將商品依照 "Layout Type" 分組 (或是你也可以維持依照 Category 分組)
// 這裡依照 Category 分組，但會自動偵測該 Category 適合的網格
const categories = [...new Set(others.map(p => p.category))];
---

<Layout title="Home" siteTitle={config.site_title}>

    {/* --- 精選區塊 (Vertical Grid) --- */}
    {featured.length > 0 && (
        <section>
            <h2>FEATURED <span>精選商品</span></h2>
            <div class="p-grid grid-vertical">
                {featured.map(product => (
                    <ProductCard product={product} solidTagsList={solidTagsList} />
                ))}
            </div>
        </section>
    )}

    {/* --- 分類區塊 (自動適應 V5 網格密度) --- */}
    {categories.map(cat => {
        const catItems = others.filter(p => p.category === cat);
        const gridClass = getGridClass(catItems);

        return (
            <section>
                <h2>{cat} <span>COLLECTION</span></h2>
                <div class={`p-grid ${gridClass}`}>
                    {catItems.map(product => (
                        <ProductCard product={product} solidTagsList={solidTagsList} />
                    ))}
                </div>
            </section>
        );
    })}

</Layout>
